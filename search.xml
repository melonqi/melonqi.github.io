<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>textencode</title>
      <link href="/2019/01/24/textencode/"/>
      <url>/2019/01/24/textencode/</url>
      
        <content type="html"><![CDATA[<p><img src="textencode.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TextCode</title>
      <link href="/2019/01/16/TextCode/"/>
      <url>/2019/01/16/TextCode/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>struct库的使用</title>
      <link href="/2019/01/13/struct/"/>
      <url>/2019/01/13/struct/</url>
      
        <content type="html"><![CDATA[<p>在解析自定义的二进制的文件格式，或者已知的一些文件格式的时候，比如png图片，tcp包，就需要struct库；</p><p>解析二进制文件长需要的函数有从buffer中读取char(一个字节)，short(两个字节)，int(4字节)，string(n个char)，这些struct都可以很好的胜任。<a href="https://docs.python.org/2/library/struct.html" target="_blank" rel="noopener">官方说明</a></p><a id="more"></a><p>struct生成或者解析二进制的使用方法，很像格式化输出，即使用特定的字符来输出自己想要的格式；</p><h2 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h2><p><code>except</code>：<code>struct.error</code> </p><p><code>struct.pack(fmt,v1,v2,...)</code>: 返回以<code>fmt</code>格式指定的<code>v1,v2,…</code>组成的string; 要求<code>v1,v2,...</code>能够严格匹配<code>fmt</code></p><p><code>struct.pack_into(fmt,buffer,offset,v1,v2,...)</code>: 从buffer的offset处，组成以<code>fmt</code>格式指定组成的<code>v1,v2,...</code></p><p><code>struct.unpack(fmt,string)</code>: 使用<code>fmt</code>解析string，返回结果为tuple，即使只包含一个值。要求<code>len(string)</code>与<code>calcsize(fmt)</code>相同</p><p><code>struct.unpack_from(fmt,buffer[,offset=0])</code>: 从buffer的offset处开始以<code>fmt</code>指定的格式解析，返回结果为tuple，要求<code>len(buffer[offset:])&gt;=calcsize(fmt)</code></p><p><code>struct.calcsize(fmt)</code>: 计算给定格式的字节大小</p><p>fmt可以指定字节序，字符类型等</p><h2 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h2><p>做过相关网络数据包开发的都接触过本地序和网络序；</p><p>对于网络序，使用的大端序(big endian)。</p><p>本地序跟CPU相关</p><ol><li><p>对于Intel X86和AMD64(X86-64)都是小端序(little-endian)</p></li><li><p>Motorola 68000 和 PowerPC G5是大端序</p></li><li><p>对于ARM和Intel Itanium 是双端序</p></li></ol><p>可以使用<code>sys.byteorder</code>来获取当前系统的类型。</p><p>那么什么是大端序，小端序？</p><p>大端序：数据的高位字节存放在地址的低端，低位字节存放在地址的高端</p><p>小端序：数据的高位自己存放在地址的高端，低位字节存放在地址的低端</p><p>数据的高位和低位：举例，<code>int a = 0x12345678</code>, 坐标<code>12</code>是高位字节，右边<code>78</code>是低位字节，从左到右，从高到低；</p><p>地址的高端和低端(假设是64位机器，一个地址是64位)：</p><p><code>0x00000001</code></p><p><code>0x00000002</code></p><p><code>0x00000003</code></p><p><code>0x00000004</code></p><p>从上到下，由低到高，地址值小的为低端，地址值大的为高端。</p><p>假设从地址<code>0x00000001</code>开始存储数<code>0x12345678</code>，则</p><p>大端序存放方式(按原来顺序存放):</p><p><code>0x00000001</code>    –<code>12</code></p><p><code>0x00000002</code>    –<code>34</code></p><p><code>0x00000003</code>    –<code>56</code></p><p><code>0x00000004</code>    –<code>78</code></p><p>小端序存放方式(按颠倒顺序存放)：</p><p><code>0x00000001</code>    –<code>78</code></p><p><code>0x00000002</code>    –<code>56</code></p><p><code>0x00000003</code>    –<code>34</code></p><p><code>0x00000004</code>    –<code>12</code></p><p>struct可以指定使用大端序还是小端序来解析或者生成数据。</p><table><thead><tr><th>Character</th><th>Byte order</th><th>Size</th><th>Alignment</th></tr></thead><tbody><tr><td>@</td><td>native</td><td>native</td><td>native</td></tr><tr><td>=</td><td>native</td><td>standard</td><td>none</td></tr><tr><td>&lt;</td><td>little-endian</td><td>standard</td><td>none</td></tr><tr><td>&gt;</td><td>big-endian</td><td>standard</td><td>none</td></tr><tr><td>!</td><td>network(=big-endian)</td><td>standard</td><td>none</td></tr></tbody></table><p>如果不指定，<code>@</code>是默认值。</p><p>Native size和alignment由C语言的<code>sizeof</code>表达式决定,  即结构体的字节对齐规则。<a href="https://www.cnblogs.com/clover-toeic/p/3853132.html" target="_blank" rel="noopener">C语言的字节对齐问题</a></p><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><table><thead><tr><th>Format</th><th>C Type</th><th>Python type</th><th>Standard size</th><th>Notes</th></tr></thead><tbody><tr><td>x</td><td>pad byte</td><td>no value</td><td></td><td></td></tr><tr><td>c</td><td>char</td><td>string of length 1</td><td>1</td><td></td></tr><tr><td>b</td><td>signed char</td><td>integer</td><td>1</td><td>(3)</td></tr><tr><td>B</td><td>unsigned char</td><td>integer</td><td>1</td><td>(3)</td></tr><tr><td>?</td><td>_Bool</td><td>bool</td><td>1</td><td>(1)</td></tr><tr><td>h</td><td>short</td><td>integer</td><td>2</td><td>(3)</td></tr><tr><td>H</td><td>unsigned short</td><td>integer</td><td>2</td><td>(3)</td></tr><tr><td>i</td><td>int</td><td>integer</td><td>4</td><td>(3)</td></tr><tr><td>I</td><td>unsigned int</td><td>integer</td><td>4</td><td>(3)</td></tr><tr><td>l</td><td>long</td><td>integer</td><td>4</td><td>(3)</td></tr><tr><td>L</td><td>unsigned long</td><td>integer</td><td>4</td><td>(3)</td></tr><tr><td>q</td><td>long long</td><td>integer</td><td>8</td><td>(2),(3)</td></tr><tr><td>Q</td><td>unsigned long long</td><td>integer</td><td>8</td><td>(2),(3)</td></tr><tr><td>f</td><td>float</td><td>float</td><td>4</td><td>(4)</td></tr><tr><td>d</td><td>double</td><td>float</td><td>8</td><td>(4)</td></tr><tr><td>s</td><td>char[]</td><td>string</td><td></td><td></td></tr><tr><td>p</td><td>char[]</td><td>string</td><td></td><td></td></tr><tr><td>P</td><td>void *</td><td>integer</td><td></td><td>(5),(3)</td></tr></tbody></table><p>Notes:</p><ol><li><p><code>?</code> 是C99中的<code>_Bool</code>, 如果不可用， 则生成<code>char</code>, 一个字节；</p></li><li><p><code>q</code>和<code>Q</code>只用当C编译器支持<code>long long</code>;</p></li><li><p>当pack一个非integer类型的时候，如果此非integer有<code>__index__()</code>函数，则pack<code>__init__()</code>的返回值；若没有<code>__index__()</code>或者调用<code>__index__()</code>报异常，则尝试<code>__int__()</code>函数，若没有<code>__int__()</code>则报<code>DeprecationWarning</code>;</p></li><li><p>对于浮点类型，<code>f</code>使用IEEE 754 binary32，<code>d</code>使用binary64标准</p></li><li><p><code>P</code>只在native byte ordering使用</p></li><li><p><code>4h</code>等价于<code>hhhh</code></p></li><li><p><code>&#39;10s&#39;</code>代表  10-byte string, <code>&#39;10c&#39;</code> 代表 10 characters</p></li><li><p><code>p</code> 即<code>Pascal string</code>, 第一个字节代表长度，随后是字符串</p></li></ol><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>示例在big-endian机器，以native byte order,size, alignment </p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; <span class="keyword">from</span> struct <span class="keyword">import</span> *</span><br><span class="line">&gt; &gt;&gt;&gt; pack(<span class="string">'hhl'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&gt; <span class="string">'\x00\x01\x00\x02\x00\x00\x00\x03'</span></span><br><span class="line">&gt; &gt;&gt;&gt; unpack(<span class="string">'hhl'</span>, <span class="string">'\x00\x01\x00\x02\x00\x00\x00\x03'</span>)</span><br><span class="line">&gt; (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&gt; &gt;&gt;&gt; calcsize(<span class="string">'hhl'</span>)</span><br><span class="line">&gt; <span class="number">8</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BytesUtil</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bytes_to_int</span><span class="params">(byte_s)</span>:</span></span><br><span class="line">        <span class="comment"># little_endian</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> reversed(byte_s):</span><br><span class="line">            result = result * <span class="number">256</span> + int(b)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_byte</span><span class="params">(buffer, offset)</span>:</span></span><br><span class="line">        value = struct.unpack_from(<span class="string">"B"</span>, buffer, offset)[<span class="number">0</span>]</span><br><span class="line">        offset += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> value, offset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_short</span><span class="params">(buffer, offset)</span>:</span></span><br><span class="line">        value = struct.unpack_from(<span class="string">"H"</span>, buffer, offset)[<span class="number">0</span>]</span><br><span class="line">        offset += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> value, offset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_int</span><span class="params">(buffer, offset)</span>:</span></span><br><span class="line">        value = struct.unpack_from(<span class="string">"I"</span>, buffer, offset)[<span class="number">0</span>]</span><br><span class="line">        offset += <span class="number">4</span></span><br><span class="line">        <span class="keyword">return</span> value, offset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_int24</span><span class="params">(buffer, offset)</span>:</span></span><br><span class="line">        value, offset = BytesUtil.get_byte_n(<span class="number">3</span>, buffer, offset)</span><br><span class="line">        <span class="keyword">return</span> BytesUtil.bytes_to_int(value), offset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_byte_n</span><span class="params">(n, buffer, offset)</span>:</span></span><br><span class="line">        value = struct.unpack_from(<span class="string">"%dB"</span> % (n), buffer, offset)</span><br><span class="line">        offset += n</span><br><span class="line">        <span class="keyword">return</span> value, offset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_short_n</span><span class="params">(n, buffer, offset)</span>:</span></span><br><span class="line">        value = struct.unpack_from(<span class="string">"%dH"</span> % (n), buffer, offset)</span><br><span class="line">        offset += <span class="number">2</span>*n</span><br><span class="line">        <span class="keyword">return</span> value, offset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_int_n</span><span class="params">(n, buffer, offset)</span>:</span></span><br><span class="line">        value = struct.unpack_from(<span class="string">"%dI"</span> % (n), buffer, offset)</span><br><span class="line">        offset += <span class="number">4</span>*n</span><br><span class="line">        <span class="keyword">return</span> value, offset</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
