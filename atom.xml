<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Melonqi Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://melonqi.github.io/"/>
  <updated>2019-02-14T13:47:53.751Z</updated>
  <id>http://melonqi.github.io/</id>
  
  <author>
    <name>melonqi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>makefile</title>
    <link href="http://melonqi.github.io/2019/02/14/makefile/"/>
    <id>http://melonqi.github.io/2019/02/14/makefile/</id>
    <published>2019-02-14T13:22:10.000Z</published>
    <updated>2019-02-14T13:47:53.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Makefile是什么"><a href="#Makefile是什么" class="headerlink" title="Makefile是什么"></a>Makefile是什么</h2><h3 id="关于程序的编译和链接"><a href="#关于程序的编译和链接" class="headerlink" title="关于程序的编译和链接"></a>关于程序的编译和链接</h3><p>　　一般来说，无论是C还是C++，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile），一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。</p><p>　　编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。<br><a id="more"></a><br>　　链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来 链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</p><blockquote><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</p></blockquote><p>简单的说，Makefile是告诉用户程序该怎么编译，用户可以简单使用<code>make</code>命令就能编译一个软件，极大地提升了编程效率。 </p><blockquote><p><code>make</code>命令默认使用名称为Makefile或makefile的文件作为编译规则，若想指定makefile文件，使用<code>make -f file</code></p></blockquote><h2 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h2><p>Makefile简单的规则为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标 : 需要的条件  (注意冒号两边有空格)</span><br><span class="line">命令 (注意前面用tab键开头)</span><br></pre></td></tr></table></figure><ol><li>目标可以是一个或多个，可以是Object File，也可以是执行文件，甚至可以是一个标签。</li><li>需要的条件就是生成目标所需要的文件或目标</li><li>命令就是生成目标所需要执行的脚本</li></ol><p>　　总结一下，就是说一条makefile规则规定了编译的依赖关系，也就是目标文件依赖于条件，生成规则用命令来描述。在编译时，如果需要的条件的文件比目标更新的话，就会执行生成命令来更新目标。</p><h2 id="万能Makefile模板"><a href="#万能Makefile模板" class="headerlink" title="万能Makefile模板"></a>万能Makefile模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#指定编译器</span><br><span class="line">CC = g++</span><br><span class="line"></span><br><span class="line">#定义rm命令</span><br><span class="line">RM = /bin/rm</span><br><span class="line"></span><br><span class="line">#定义echo命令，用于打印信息</span><br><span class="line">ECHO = /bin/echo</span><br><span class="line"></span><br><span class="line">#编译选项，定义了HAVE_DEBUG变量，用于调试</span><br><span class="line">DEFINES = -DHAVE_DEBUG  </span><br><span class="line"></span><br><span class="line">#编译选项，</span><br><span class="line">#-g是生成debug版本，-O2代码优化，</span><br><span class="line">#-Wall提示所用waring，可根据实际需要来选择</span><br><span class="line">CPPFLAGS = -g -O2 -Wall</span><br><span class="line"></span><br><span class="line">#把include 加入到搜索头文件的路径列表中</span><br><span class="line">INCLUDES = -Iinclude </span><br><span class="line"></span><br><span class="line">#-lcrypto进行链接时搜索名为crypto的库，</span><br><span class="line">#-lssl 进行链接时搜索名为ssl的库</span><br><span class="line">#-Llib 把lib加入到搜索库文件的路径列表中</span><br><span class="line">LDFLAGS = -lcrypto -lssl</span><br><span class="line"></span><br><span class="line">#定义生成可执行文件名</span><br><span class="line">MAIN_EXE = hello</span><br><span class="line"></span><br><span class="line">#定义变量，定义all操作的条件，可包含多个要生成的可执行文件</span><br><span class="line">#例如EXECUTABLES = main1 main2，这样执行all操作就会分别生成main1 和 main2</span><br><span class="line">EXECUTABLES = $(MAIN_EXE)</span><br><span class="line"></span><br><span class="line">#指定源文件，</span><br><span class="line">#wildcard是通配符，搜索./src目录下所有以.cpp结尾的文件，</span><br><span class="line">#生成一个以空格间隔的文件名列表，并赋值给SOURCES. </span><br><span class="line">#当前目录文件只有文件名, 子目录下的文件名包含路径信息，比如./src/bar.cpp。</span><br><span class="line">SOURCES = $(wildcard src/*.cpp)</span><br><span class="line"></span><br><span class="line">#指定要生成的*.o文件，</span><br><span class="line">#patsubst是pattern substitute的缩写，匹配替代的意思。</span><br><span class="line">#这句是在SOURCES中找到所有.cpp 结尾的文件，然后把所有的.cpp换成.o。</span><br><span class="line">OBJECTS = $(patsubst %.cpp, %.o, $(SOURCES))</span><br><span class="line"></span><br><span class="line">#PHONY 目标并非实际的文件名：只是在显式请求时执行命令的名字。</span><br><span class="line">#有两种理由需要使用PHONY 目标：避免和同名文件冲突，改善性能。</span><br><span class="line">#如果编写一个规则，并不产生目标文件，则其命令在每次make 该目标时都执行。</span><br><span class="line">.PHONY: all clean</span><br><span class="line"></span><br><span class="line">#目标为all需要条件，$(EXECUTABLES)</span><br><span class="line">#由于.PHONY中有all,可解决执行文件生成的依赖关系</span><br><span class="line">all: $(EXECUTABLES) </span><br><span class="line"></span><br><span class="line">#生成$(MAIN_EXE)，需要条件$(OBJECTS)</span><br><span class="line">#使用$(CC)来生成$(MAIN_EXE)，具体g++用法请自行查阅</span><br><span class="line">#$@表示目标</span><br><span class="line">#$^所有依赖目标的集合，以空格分隔。</span><br><span class="line">#如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</span><br><span class="line">#该命令在本makefile中被扩展为，假设$(OBJECTS) = src/bar.o</span><br><span class="line">#hello: src/bar.o</span><br><span class="line">#g++ -o hello bar.o  -lcrypto -lssl</span><br><span class="line">$(MAIN_EXE): $(OBJECTS)</span><br><span class="line">$(CC) -o $@ $^ $(LDFLAGS)</span><br><span class="line"></span><br><span class="line">#生成$(MAIN_EXE)，需要先生成$(OBJECTS)</span><br><span class="line">#目标是生成src/%.o, 需要src/%.cpp，其中%为通配符</span><br><span class="line">#$&lt; 表示依赖目标中第一个目标的名字。</span><br><span class="line">#如果依赖目标是以模式(%)定义的，那么&quot;$&lt;&quot;将是符合模式的一系列文件集。（注：是一个一个取出来的）</span><br><span class="line">#命令被扩展为</span><br><span class="line">#src/bar.o: src/bar.cpp</span><br><span class="line">#g++ -o src/bar.o -c src/bar.cpp -DHAVE_DEBUG -g -O2 -Wall -Iinclude </span><br><span class="line">src/%.o: src/%.cpp</span><br><span class="line">$(CC) -o $@ -c $&lt; $(DEFINES) $(CPPFLAGS) $(INCLUDES)</span><br><span class="line"></span><br><span class="line">#执行clean操作</span><br><span class="line">clean:</span><br><span class="line">- $(RM) -rf $(OBJECTS) $(MAIN_EXE)</span><br></pre></td></tr></table></figure><p>.PHONY的用法详细可参考<a href="http://blog.chinaunix.net/uid-28458801-id-3452277.html" target="_blank" rel="noopener">.PHONY的用法</a></p><p>\$@等都是Makefile中的特殊变量，更多特殊变量请参考：<a href="http://blog.csdn.net/u012474286/article/details/20715331" target="_blank" rel="noopener">makefile中的特殊变量</a></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>新建一个项目，要实现的功能是对字符串”1234“计算MD5值。</p><p>include/common.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _COMMON_H</span><br><span class="line">#define _COMMON_H</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">std::string get_string_MD5(const std::string str); </span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>src/common.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &lt;openssl/md5.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">std::string get_string_MD5(const std::string str)</span><br><span class="line">&#123;</span><br><span class="line">MD5_CTX ctx;</span><br><span class="line">char *data = (char *)str.c_str();</span><br><span class="line">unsigned char md[16]=&#123;0&#125;;</span><br><span class="line">char buf[33]=&#123;0&#125;;</span><br><span class="line">char tmp[3]=&#123;0&#125;;</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">MD5_Init(&amp;ctx);</span><br><span class="line">MD5_Update(&amp;ctx,data,strlen(data));</span><br><span class="line">MD5_Final(md,&amp;ctx);</span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;16;i++)</span><br><span class="line">&#123;</span><br><span class="line">sprintf(tmp,&quot;%X&quot;,md[i]);</span><br><span class="line">strcat(buf,tmp);</span><br><span class="line">&#125;</span><br><span class="line">return std::string(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src/main.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;1234&quot;;</span><br><span class="line">string after = get_string_MD5(str);</span><br><span class="line">cout&lt;&lt;&quot;Before MD5: &quot;&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;After MD5: &quot;&lt;&lt;after&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例需要安装openssl库；在目录下运行<code>make</code>，然后运行<code>./hello</code></p><p>整个示例的下载地址：<a href="md5.zip">md5.zip</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Makefile是什么&quot;&gt;&lt;a href=&quot;#Makefile是什么&quot; class=&quot;headerlink&quot; title=&quot;Makefile是什么&quot;&gt;&lt;/a&gt;Makefile是什么&lt;/h2&gt;&lt;h3 id=&quot;关于程序的编译和链接&quot;&gt;&lt;a href=&quot;#关于程序的编译和链接&quot; class=&quot;headerlink&quot; title=&quot;关于程序的编译和链接&quot;&gt;&lt;/a&gt;关于程序的编译和链接&lt;/h3&gt;&lt;p&gt;　　一般来说，无论是C还是C++，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile），一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。&lt;/p&gt;
&lt;p&gt;　　编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。&lt;br&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://melonqi.github.io/tags/C-C/"/>
    
      <category term="makefile" scheme="http://melonqi.github.io/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>TopK和堆排序</title>
    <link href="http://melonqi.github.io/2019/02/08/TopK/"/>
    <id>http://melonqi.github.io/2019/02/08/TopK/</id>
    <published>2019-02-08T14:41:07.000Z</published>
    <updated>2019-02-09T09:31:35.556Z</updated>
    
    <content type="html"><![CDATA[<p>在处理海量数据或者数据流里经常会碰到提取前K个最大值，前K个最小值的问题；面试的时候也特别喜欢问此种问题。</p><p>本文先介绍了大顶堆和小顶堆，然后给出利用大顶堆和小顶堆算法解决TopK问题，最后给出了堆排序。</p><p>所有代码位于<a href="https://github.com/melonqi/TopK" target="_blank" rel="noopener">TopK</a></p><a id="more"></a><h2 id="大顶堆和小顶堆"><a href="#大顶堆和小顶堆" class="headerlink" title="大顶堆和小顶堆"></a>大顶堆和小顶堆</h2><p>大顶堆和小顶堆都是完全二叉树，由于可以使用数组nums表示完全二叉树，所以存储结构用数组很方便。</p><p>父节点索引为<code>i</code>，则左孩子节点索引为<code>2*i+1</code>，右孩子节点索引为<code>2*i+2</code></p><p><img src="full-binary-tree.png" alt=""></p><p>根节点索引为0，索引为1的节点为根节点的左孩子，索引为2的节点为根节点的右孩子。</p><p>即值为9节点的左孩子值为8，右孩子值为7。</p><h3 id="大顶堆-Max-Heap"><a href="#大顶堆-Max-Heap" class="headerlink" title="大顶堆(Max-Heap)"></a>大顶堆(Max-Heap)</h3><p>每个结点的值都大于或等于其左右孩子结点的值，即<code>nums[i]&gt;=nums[2*i+1] &amp;&amp; nums[i]&gt;=nums[2*i+2]</code>。</p><p><img src="max-heap.png" alt=""></p><p>可以看到堆顶即根节点的值最大；</p><p>大顶堆可以用来找前K个最小值。</p><p>假设堆里面应该有K个值，其中根节点值最大，此时新来一个值。</p><ol><li>如果比根节点大，则说明比堆里面其他节点都大，肯定不在前K个最小值里面；</li><li>如果比根节点小，则弹出最大的值，放入该值，即用该值替换根节点，然后重新调整形成大顶堆，用于下一次值调整。</li></ol><p>同时大顶堆可用于升序堆排序，将大顶堆的根节点值与最后一个节点值交换，剩余的元素在构建大顶堆，依次构建形成升序。具体可以看后面的堆排序。</p><h3 id="小顶堆-Min-Heap"><a href="#小顶堆-Min-Heap" class="headerlink" title="小顶堆(Min-Heap)"></a>小顶堆(Min-Heap)</h3><p>每个结点的值都大于或等于其左右孩子结点的值，即<code>nums[i]&lt;=nums[2*i+1] &amp;&amp; nums[i]&lt;=nums[2*i+2]</code>。</p><p><img src="min-heap.png" alt=""></p><p>同大顶堆，小顶堆用来找前K个最大值，用于堆排序的降序。</p><h2 id="堆化，以大顶堆为例"><a href="#堆化，以大顶堆为例" class="headerlink" title="堆化，以大顶堆为例"></a>堆化，以大顶堆为例</h2><p>假设树为</p><p><img src="init.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(<span class="built_in">array</span>, <span class="built_in">array</span> + <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="comment">//对nums进行堆化，形成大顶堆</span></span><br><span class="line">heapify(nums);</span><br><span class="line"><span class="comment">//输出堆化之后的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出结果</p><blockquote><p>9    7    8    4    6    5</p></blockquote><p>对应的完全二叉树为</p><p><img src="finial.png" alt=""></p><p>大顶堆的每一棵子树都是大顶堆，适用于递归算法；算法heapify的核心思想，从底向上，使得每棵树包括子树都变成大顶堆；类似于冒泡排序，从父节点和左右孩子节点选择最大的值作为父节点的值，由于是从底向上，能够保证根节点是最大值；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> array_size = nums.size();</span><br><span class="line">    <span class="comment">//(array_size-1)/2第一个非叶子节点</span></span><br><span class="line">    <span class="comment">//自底向上遍历所有的非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array_size - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        build_heap(nums, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法build_heap会从父节点i开始构建大顶堆，由于是自底向上构建的，父节点i的左右孩子节点都已经是大顶堆了。如果父节点的值比左右孩子节点的值都大，则不用调整该树已经是大顶堆了；否则，交换父节点和左右孩子值最大的节点，由于有可能使孩子变成的非大顶堆，就需要在调用build_heap调整一下该孩子节点再次成为大顶堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * parent + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> largest = parent;</span><br><span class="line">    <span class="keyword">int</span> array_size = nums.size();</span><br><span class="line">    <span class="comment">//max-heap</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; array_size &amp;&amp; nums[left] &gt; nums[largest])</span><br><span class="line">    &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; array_size &amp;&amp; nums[right] &gt; nums[largest])</span><br><span class="line">    &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != parent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(nums[largest], nums[parent]);</span><br><span class="line">        <span class="comment">//swap之后孩子节点可能不是大顶堆了，需要调整一下</span></span><br><span class="line">        build_heap(nums, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对树[9, 4, 5, 7, 6, 8]进行调整，非叶子节点的索引为[2,1,0]</p><ol><li><p>调整非叶子节点2，的节点2值为5，只有左孩子节点值为8；交换5，8，由于左孩子节点无孩子节点，不需要继续调整。</p><p><img src="step1.png" alt=""></p></li><li><p>调整非叶子节点1，由于9&gt;7&amp;&amp;9&gt;6，所以该树不用调整</p><p><img src="step2.png" alt=""></p></li><li><p>调整节点0，由于左孩子值最大，交换节点0，节点1的值</p><p><img src="step3.1.png" alt=""></p><p>由于节点1不再是满足大顶堆的性质，需要调整成为大顶堆</p><p><img src="step3.2.png" alt=""></p><p>调整之后的大顶堆为[9,7,8,4,6,5]</p></li></ol><p>整体代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * parent + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> largest = parent;</span><br><span class="line">    <span class="keyword">int</span> array_size = nums.size();</span><br><span class="line">    <span class="comment">//max-heap</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; array_size &amp;&amp; nums[left] &gt; nums[largest])</span><br><span class="line">    &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; array_size &amp;&amp; nums[right] &gt; nums[largest])</span><br><span class="line">    &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != parent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(nums[largest], nums[parent]);</span><br><span class="line">        build_heap(nums, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> array_size = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array_size - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        build_heap(nums, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(<span class="built_in">array</span>, <span class="built_in">array</span> + <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    heapify(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TopK"><a href="#TopK" class="headerlink" title="TopK"></a>TopK</h2><p>有了上面的heapify构建TopK就容易多了。</p><p>以查找前K个最小值为例，使用大顶堆。固定堆大小为K，遍历所有元素。</p><p>如果堆大小小于K，添加元素到堆中，然后堆化，其中根节点是最大值；</p><p>如果堆大小为K，比较根节点与元素的大小。</p><ol><li>如果比根节点大，则比堆中其他K-1个元素都大，所以不会出现前K个最小值中；</li><li>如果比跟节点小，用该元素替换堆中最大值，即根节点，然后调整根节点为大顶堆(孩子节点已经是大顶堆了)。</li></ol><p>具体代码如下，</p><ol><li>指定compare函数可以支持大顶堆或者小顶堆</li><li>push函数先TopK中添加元素</li><li>get函数获取前K个元素；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TOPK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOPK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopK</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">TopK(<span class="keyword">int</span> k, <span class="keyword">bool</span> (*compare_func)(<span class="keyword">const</span> T &amp;t1, <span class="keyword">const</span> T &amp;t2)) &#123;</span><br><span class="line">k_ = k;</span><br><span class="line">compare_ = compare_func;</span><br><span class="line">array_.reserve(k_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> array_size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; get() &#123;</span><br><span class="line"><span class="keyword">return</span> array_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">int</span> array_size, <span class="keyword">int</span> root)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> k_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; array_;</span><br><span class="line"><span class="keyword">bool</span> (*compare_)(<span class="keyword">const</span> T &amp;t1, <span class="keyword">const</span> T &amp;t2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> TopK&lt;T&gt;::heapify(<span class="keyword">int</span> array_size) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (array_size - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">build_heap(array_size, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> TopK&lt;T&gt;::push(<span class="keyword">const</span> T &amp;value) &#123;</span><br><span class="line"><span class="keyword">if</span> (array_.size() &lt; k_) &#123;</span><br><span class="line"><span class="comment">//array has less than k_ elements</span></span><br><span class="line">array_.push_back(value);</span><br><span class="line">heapify(array_.size());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//array has k_ elements</span></span><br><span class="line"><span class="comment">//user define compare func</span></span><br><span class="line"><span class="keyword">if</span> (compare_ == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//if heap is min-heap, compare is greater func</span></span><br><span class="line"><span class="comment">//if heap is max-heap, compare is less func</span></span><br><span class="line"><span class="keyword">if</span> (compare_(array_[<span class="number">0</span>], value)) &#123;</span><br><span class="line"><span class="comment">//the value need to insert heap</span></span><br><span class="line">array_[<span class="number">0</span>] = value;</span><br><span class="line">        <span class="comment">//0 for root</span></span><br><span class="line">build_heap(k_,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> TopK&lt;T&gt;::build_heap(<span class="keyword">int</span> array_size, <span class="keyword">int</span> root) &#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">2</span> * root + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> largest = root;</span><br><span class="line"><span class="keyword">if</span> (left &lt; array_size &amp;&amp; compare_(array_[left], array_[largest])) &#123;</span><br><span class="line">largest = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (right &lt; array_size &amp;&amp; compare_(array_[right], array_[largest])) &#123;</span><br><span class="line">largest = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (largest != root) &#123;</span><br><span class="line"><span class="built_in">std</span>::swap(array_[largest], array_[root]);</span><br><span class="line">build_heap(array_size, largest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//TOPK_H</span></span></span><br></pre></td></tr></table></figure><p>测试代码，使用小顶堆找出[4, 5, 1, 9, 8, 0, 3, 2]中Top3最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TopK.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//max-heap</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">max_heap_compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;t1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 &gt; t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//min-heap</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">min_heap_compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;t1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 &lt; t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> array_len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    TopK&lt;<span class="keyword">int</span>&gt; top_k(<span class="number">3</span>, min_heap_compare);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        top_k.push(<span class="built_in">array</span>[i]);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = top_k.get();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出</p><blockquote><p>4<br>4 5<br>1 5 4<br>4 5 9<br>5 8 9<br>5 8 9<br>5 8 9<br>5 8 9</p></blockquote><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是一种<strong>选择排序</strong>，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序</p><p>以升序为例，构建大顶堆。要排序的数组array大小为n</p><ol><li>利用build_heap算法，对array[0,…,n-1]进行堆化，需要自底向上调整所有非叶子节点，使整棵树变成大顶堆，其中根节点为数组最大值，交换array[0]和array[n-1]</li><li>对array[o,…,n-2]进行堆化，这里只需要对堆化根节点，根节点为最大值，交换array[0]和array[n-2]</li><li>依次循环步骤2之至堆中只有一个元素，此时数据已经排好序</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> array_len, <span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = root * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> largest = root;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; array_len &amp;&amp; <span class="built_in">array</span>[left] &gt; <span class="built_in">array</span>[largest])</span><br><span class="line">    &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &lt; array_len &amp;&amp; <span class="built_in">array</span>[right] &gt; <span class="built_in">array</span>[largest])</span><br><span class="line">    &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largest != root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(<span class="built_in">array</span>[largest], <span class="built_in">array</span>[root]);</span><br><span class="line">        build_heap(<span class="built_in">array</span>, array_len, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> array_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//first build heap make sure the tree is a heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array_len - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        build_heap(<span class="built_in">array</span>, array_len, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array_len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//put the max value to the last index</span></span><br><span class="line">        <span class="built_in">std</span>::swap(<span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[i]);</span><br><span class="line">        build_heap(<span class="built_in">array</span>, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> array_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> array_len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    heap_sort(<span class="built_in">array</span>, array_len);</span><br><span class="line">    print_array(<span class="built_in">array</span>, array_len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果</p><blockquote><p>1 2 3 4 5 6 7 8 9</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在处理海量数据或者数据流里经常会碰到提取前K个最大值，前K个最小值的问题；面试的时候也特别喜欢问此种问题。&lt;/p&gt;
&lt;p&gt;本文先介绍了大顶堆和小顶堆，然后给出利用大顶堆和小顶堆算法解决TopK问题，最后给出了堆排序。&lt;/p&gt;
&lt;p&gt;所有代码位于&lt;a href=&quot;https://github.com/melonqi/TopK&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TopK&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://melonqi.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>float有效位丢失</title>
    <link href="http://melonqi.github.io/2019/01/30/float/"/>
    <id>http://melonqi.github.io/2019/01/30/float/</id>
    <published>2019-01-30T01:07:22.000Z</published>
    <updated>2019-01-30T02:29:04.710Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目过程中，为了节省存储空间，使用float而不是double来存储浮点数，结果遇到了float溢出的问题。当时还觉得奇怪，float表示范围挺大的啊，有没有超范围，怎么还会溢出？后来试验并查证了float的存储结构，有了答案，原来是float的有效位丢失了。</p><a id="more"></a><p>先来看试验bug复盘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f1 = <span class="number">220000000</span>, f2 = <span class="number">8.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f + %f = %f\n"</span>, f1, f2, f1 + f2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来预期程序会输出<code>220000000.0+8.0=220000008.0</code>, 结果大相径庭。</p><p>程序输出</p><blockquote><p>220000000.000000 + 8.000000 = 220000000.000000</p></blockquote><p>结果说明，加不加8.0的结果不变，这种隐藏的bug真的是难以排除。查阅了相关资料之后原来是自己才疏学浅。</p><h2 id="float的存储结构"><a href="#float的存储结构" class="headerlink" title="float的存储结构"></a>float的存储结构</h2><p>任何数据在内存中都是以二进制的形式存储的, 包括float。 浮点数在二进制科学表示法中的表示为<code>S=M*2^N</code>, 由三部分组成，符号位+阶码(N)+尾数(M)。float 二进制32位，其中符号位1位，阶码8位，尾数23位。</p><table><thead><tr><th></th><th>31</th><th>30-23</th><th>22-0</th></tr></thead><tbody><tr><td>float</td><td>符号位</td><td>阶码</td><td>尾数</td></tr></tbody></table><p>符号位，0表示正，1表示负</p><p>阶码：8位阶码N=[-127,127], 因为指数可正可负，所以指数部分的存储采用移位存储，存储的数据为元数据+127</p><p>尾数：有效数字位，即部分二进制位(小数点后面的二进制位)，因为规定M的整数部分恒为1，所以这个1就不进行存储了，即<code>S=1.xxx*2^N</code></p><p>举例：</p><p>125.5的float标准浮点格式，用二进制表示为<code>1111101.1=1.1111011*2^6</code>, 则阶码为6，加上127为133，则表示为10000101，而对于尾数将整数部分1去掉，为1111011，在其后面补0使其位数达到23位，则为11110110000000000000000</p><p>所以125.5的float存储二进制为0 10000101 11110110000000000000000</p><p>反过来若要根据二进制形式求算浮点数如0 10000101 11110110000000000000000</p><p>由于符号为为0，则为正数。阶码为133-127=6，尾数为11110110000000000000000，则其真实尾数为1.1111011。所以其大小为<code>1.1111011*2^6</code>，将小数点右移6位，得到1111101.1，而1111101的十进制为125，0.1的十进制为<code>1*2^(-1)=0.5</code>，所以其大小为125.5</p><p>由上分析可知float型数据最大表示范围为<code>1.11111111111111111111111*2^127=3.4*10^38</code></p><h2 id="float有效位丢失"><a href="#float有效位丢失" class="headerlink" title="float有效位丢失"></a>float有效位丢失</h2><p>因为尾数为23+1=24位，如果数据尾数多于24位，就会造成精度丢失。</p><p>以220000000.0为例， <code>220000000.0=1101 0001 1100 1110 1111 0000 0000.0=1.101 0001 1100 1110 1111*2^27</code></p><p>其中阶码为27，移位码为27+127=154=10011010 ，尾数为101 0001 1100 1110 1111，该数字的二进制表示为 0 10011010 10100011100111011110000</p><p>同理 220000000.0+8.0=220000008.0 的阶码的移位码为10011010，尾数为101 0001 1100 1110 1111 0000 1000，由于尾数为27位，有效位只有前23位，所以有效尾数为101 0001 1100 1110 1111 0000 </p><p>所以220000008.0的二进制编码为0 10011010 10100011100111011110000， 跟220000000.0 是一样的，符合结果预期。</p><p>再做一个实验证实一下，220000000.0+16.0=2200000016.0 在float下应该是正确的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f1 = <span class="number">220000000</span>, f2 = <span class="number">16.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f + %f = %f\n"</span>, f1, f2, f1 + f2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果符合预期</p><blockquote><p>220000000.000000 + 16.000000 = 220000016.000000</p></blockquote><p>具体原因可以自己推导一下</p><p>PS: float会有精度损失问题，比如本来存的<code>float f1=220000008</code>，实际真实值为220000000</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目过程中，为了节省存储空间，使用float而不是double来存储浮点数，结果遇到了float溢出的问题。当时还觉得奇怪，float表示范围挺大的啊，有没有超范围，怎么还会溢出？后来试验并查证了float的存储结构，有了答案，原来是float的有效位丢失了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://melonqi.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>geojson</title>
    <link href="http://melonqi.github.io/2019/01/27/geojson/"/>
    <id>http://melonqi.github.io/2019/01/27/geojson/</id>
    <published>2019-01-27T10:49:59.000Z</published>
    <updated>2019-01-27T13:04:25.292Z</updated>
    
    <content type="html"><![CDATA[<p><em>Geographic JSON</em> 简称GeoJson，是一种使用json格式的地理信息数据结构。</p><a id="more"></a><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"Feature"</span>,</span><br><span class="line">  <span class="attr">"geometry"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"Point"</span>,</span><br><span class="line">    <span class="attr">"coordinates"</span>: [<span class="number">125.6</span>, <span class="number">10.1</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Dinagat Islands"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GeoJson支持的地理信息格式有<code>Point</code>, <code>LineString</code>, <code>Polygon</code>, <code>MultiPoint</code>, <code>MultiLineString</code>, and <code>MultiPolygon</code>。</p><p>有额外属性的地理信息主体(Geometric objects)称为Feature，Feature集合称为FeatureCollection。</p><p>上述例子中，为Point Feature，经纬度坐标为125.6,10.1，有一个name属性，该Point的name为”Dinagat Islands”。</p><p>A GeoJSON FeatureCollection:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">   &#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"FeatureCollection"</span>,</span><br><span class="line"><span class="attr">"features"</span>: [&#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"Feature"</span>,</span><br><span class="line"><span class="attr">"geometry"</span>: &#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"Point"</span>,</span><br><span class="line"><span class="attr">"coordinates"</span>: [<span class="number">102.0</span>, <span class="number">0.5</span>]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"properties"</span>: &#123;</span><br><span class="line"><span class="attr">"prop0"</span>: <span class="string">"value0"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"Feature"</span>,</span><br><span class="line"><span class="attr">"geometry"</span>: &#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"LineString"</span>,</span><br><span class="line"><span class="attr">"coordinates"</span>: [</span><br><span class="line">[<span class="number">102.0</span>, <span class="number">0.0</span>],</span><br><span class="line">[<span class="number">103.0</span>, <span class="number">1.0</span>],</span><br><span class="line">[<span class="number">104.0</span>, <span class="number">0.0</span>],</span><br><span class="line">[<span class="number">105.0</span>, <span class="number">1.0</span>]</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"properties"</span>: &#123;</span><br><span class="line"><span class="attr">"prop0"</span>: <span class="string">"value0"</span>,</span><br><span class="line"><span class="attr">"prop1"</span>: <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"Feature"</span>,</span><br><span class="line"><span class="attr">"geometry"</span>: &#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"Polygon"</span>,</span><br><span class="line"><span class="attr">"coordinates"</span>: [</span><br><span class="line">[</span><br><span class="line">[<span class="number">100.0</span>, <span class="number">0.0</span>],</span><br><span class="line">[<span class="number">101.0</span>, <span class="number">0.0</span>],</span><br><span class="line">[<span class="number">101.0</span>, <span class="number">1.0</span>],</span><br><span class="line">[<span class="number">100.0</span>, <span class="number">1.0</span>],</span><br><span class="line">[<span class="number">100.0</span>, <span class="number">0.0</span>]</span><br><span class="line">]</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"properties"</span>: &#123;</span><br><span class="line"><span class="attr">"prop0"</span>: <span class="string">"value0"</span>,</span><br><span class="line"><span class="attr">"prop1"</span>: &#123;</span><br><span class="line"><span class="attr">"this"</span>: <span class="string">"that"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细的信息可以参考<a href="https://tools.ietf.org/html/rfc7946" target="_blank" rel="noopener">The GeoJSON Specification (RFC 7946)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Geographic JSON&lt;/em&gt; 简称GeoJson，是一种使用json格式的地理信息数据结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Gis" scheme="http://melonqi.github.io/tags/Gis/"/>
    
  </entry>
  
  <entry>
    <title>文本编码那些事</title>
    <link href="http://melonqi.github.io/2019/01/24/textencode/"/>
    <id>http://melonqi.github.io/2019/01/24/textencode/</id>
    <published>2019-01-24T11:45:24.000Z</published>
    <updated>2019-01-26T07:01:48.936Z</updated>
    
    <content type="html"><![CDATA[<p>程序猿都遇到过文本编码问题，看到GB2312,GBK,GB18030,Unicode,UTF-8就觉得头大。希望通过此文，可以对文本编码可以有一个透彻的了解。</p><a id="more"></a><p>计算机发明之初为英文服务的，英文字符集十分有限，使用一个char就可以表示了。</p><p>但是随着计算机的发展，ASCII就没有办法支持中文等国家的文字；于是乎就有了GB2312中文编码，同样日文，韩文等都有属于自己的编码，想要在中文系统查看其它国家的文件就需要再按照另外的编码方式解码文件；如果各国文字混编就无能为力了。这种就需要一个一统江湖的编码标准来解决这个问题，即Unicode。</p><p>Unicode规定了每个数字对应的文字是什么，但是只是一个标准而已，为了解决文件编码之后空间大小问题，就有了不同的编码方式，即UTF-8，UTF-16，UTF-32. 就好比数字1，可以用char，short，int存，但是明显用char存更省空间。</p><p><img src="textencode.png" alt="编码关系"></p><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p><img src="ascii.jpg" alt=""></p><p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。</p><p>ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。标准ASCII 码也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符。</p><p>比如0x41表示英文字母A</p><h2 id="GB2312-GBK-GB18030"><a href="#GB2312-GBK-GB18030" class="headerlink" title="GB2312,GBK,GB18030"></a>GB2312,GBK,GB18030</h2><p>GB2312，GBK，GB18030都是中文的三种编码方式，按照包含文字数据由大到小依次为GB18030，GBK，GB2312；同时GB18030兼容GBK，GBK由兼容GB2312.</p><table><thead><tr><th>编码</th><th>字符数</th><th>字符种类</th><th>存储方式</th><th>兼容性</th></tr></thead><tbody><tr><td>GB2312</td><td>6763</td><td>常见汉字</td><td>双字节</td><td>兼容ASCII</td></tr><tr><td>GBK</td><td>21886</td><td>GB2312的汉字，Big5繁体字，其他</td><td>双字节</td><td>兼容GB2312</td></tr><tr><td>GB18030</td><td>70244</td><td>GBK的汉字，少数民族的汉字，日韩汉字</td><td>单字节，双字节，四字节</td><td>兼容GBK</td></tr></tbody></table><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>GB 2312中对所收汉字进行了分区处理，每区含有94个汉字/符号，共计94个区。用所在的区和位来表示字符（实际上就是码位），因此称为区位码（或许叫区位号更为恰当）。表示方式也称为区位码。例如“万”字在45区82位，所以“万”字的区位码是：45 82（注意，GB类汉字编码为双字节编码，因此，45相当于高位字节，82相当于低位字节）。</p><p><strong>可以理解为GB2312是一个二维数组，<code>GB2312[45][82]=万</code></strong>。</p><ul><li>01~09区（682个）：特殊符号、数字、英文字符、制表符等，包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母等在内的682个全角字符；</li><li>10~15区：空区，留待扩展；在附录3，第10区推荐作为 GB 1988–80 中的94个图形字符区域（即第3区字符之半形版本）。</li><li>16~55区（3755个）：常用汉字（也称一级汉字），按拼音排序；</li><li>56~87区（3008个）：非常用汉字（也称二级汉字），按部首/笔画排序；</li><li>88~94区：空区，留待扩展。</li></ul><p>每个汉字/符号使用两个字节表示，第一个字节成为高位字节，第二字节成为低位字节。高位字节使用0xA1-0xF7，即01-87的区号加上0xA0，低字节使用0xA1-0xFE，即把01-94加上0xA0。</p><p>举例: GB2312中第一个常用汉字是”啊”，即16区的第1个汉字是”啊”, 可以理解为<code>GB2312[16][1]=啊</code>，实际存储的时候，第一个字节为0xA0+16=0xB0, 第二个字节为0xA0+1 = 0xA1, 所以在GB2312编码中，0xB0 0xA1表示汉字”啊”。</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>GBK向下与 GB 2312 完全兼容，向上支持 ISO 10646 国际标准即UCS，在前者向后者过渡过程中起到的承上启下的作用。</p><p>GBK 采用双字节表示，总体编码范围为 8140-FEFE 之间，首字节在 81-FE 之间，尾字节在 40-FE 之间，剔除 XX7F 一条线。GBK 编码区分三部分：</p><ol><li>汉字区　包括<br>GBK/2：OXBOA1-F7FE, 收录 GB 2312 汉字 6763 个，按原序排列；<br>GBK/3：OX8140-AOFE，收录 CJK 汉字 6080 个；<br>GBK/4：OXAA40-FEAO，收录 CJK 汉字和增补的汉字 8160 个。</li><li>图形符号区　包括<br>GBK/1：OXA1A1-A9FE，除 GB 2312 的符号外，还增补了其它符号<br>GBK/5：OXA840-A9AO，扩除非汉字区。</li><li>用户自定义区<br>GBK 区域中的空白区，用户可以自己定义字符。</li></ol><h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p>GB 18030 与 GB 2312-1980 和 GBK 兼容，共收录汉字70244个。</p><ul><li><p>与 UTF-8 相同，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。</p></li><li><p>编码空间庞大，最多可定义 161 万个字符。</p></li><li><p>支持中国国内少数民族的文字，不需要动用造字区。</p></li><li><p>汉字收录范围包含繁体汉字以及日韩汉字</p></li></ul><p>GB 18030 编码是一二四字节变长编码。</p><ul><li>单字节，其值从 0 到 0x7F，与 ASCII 编码兼容。</li><li>双字节，第一个字节的值从 0x81 到 0xFE，第二个字节的值从 0x40 到 0xFE（不包括0x7F），与 GBK 标准兼容。</li><li>四字节，第一个字节的值从 0x81 到 0xFE，第二个字节的值从 0x30 到 0x39，第三个字节从0x81 到 0xFE，第四个字节从 0x30 到 0x39。</li></ul><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p><p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p><p>Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询<a href="http://www.unicode.org/" target="_blank" rel="noopener">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">汉字对应表</a>。</p><p>Unicode编码范围是：0-0x10FFFF，可以容纳1114112个字符. 曾经有UCS-2，双字节编码，只支持65536个字符。</p><p>全世界的字符根本用不完了，Unicode 5.0版本中，才用了238605个码位。所以足够了。</p><p>因此从码位范围看，严格的unicode需要3个字节来存储。但是考虑到理解性和计算机处理的方便性，理论上还是用4个字节来描述。</p><h2 id="UTF-8，UTF-16，UTF-32"><a href="#UTF-8，UTF-16，UTF-32" class="headerlink" title="UTF-8，UTF-16，UTF-32"></a>UTF-8，UTF-16，UTF-32</h2><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8（UCS Transformation Format 8bit)，这个方案的意思以8位为单位来标识文字，注意并不是说一个文字用8位标识。他其实是一种MBCS方案，可变字节的。到底需要几个字节表示一个符号，这个要根据这个符号的unicode编码来决定，最多4个字节。</p><p>编码规则如下：</p><table><thead><tr><th>Unicode编码(16进制)</th><th>UTF-8 字节流(二进制)</th></tr></thead><tbody><tr><td>000000 - 00007F</td><td>0xxxxxxx</td></tr><tr><td>000080 - 0007FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>000800 - 00FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>010000 - 10FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。</p><p> UTF-8编码的最大长度是4个字节。从上表可以看出，4字节模板有21个x，即可以容纳21位二进制数字。Unicode的最大码位0x10FFFF也只有21位。 　　</p><ul><li><p>例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：1110011010110001 10001001，即E6 B1 89。 　　</p></li><li><p>例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。</p></li></ul><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>UTF16就好理解了，在这个规则下，每个符号最少占16bit。UTF16的规则说起来更简单，当符号位于0000-0xFFFF(BMP)中时，占用2byte，在符号位于0x10000-0x10FFFF(辅助平面)时，占用4byte。</p><p>UTF16这个转换的算法又是怎样的呢？</p><ol><li>辅助平面的码位是U+10000到U+10FFFF，我们得到了一个辅助平面的Unicode码时，先减去BMP的码数0x10000，得到的数介于0到0xFFFFF之间，最多用20bit表示</li><li>然后我们把20bit从中间隔开，分为高位的10bit和低位的10bit</li><li>我们知道10bit的取值范围是0到0x3FF，高位的10bit加上固定值0xD800，得到的值叫做前导代理（lead surrogate），范围是0xD800到0xDBFF</li><li>低位的10bit加上固定值0xDC00，得到的值叫做后尾代理（tail surrogate），范围是0xDC00到0xDFFF。这样一来，不仅高位和低位都落在了保留区块内，而且彼此还做了区分。</li></ol><p>　　还是举个例子。</p><p>　　Unicode码位是U+24B62是个异体字，通“碎”，位于辅助平面，我们来算一下它的UTF16编码结果</p><ol><li>首先0x24B62减去10000得到0x14B62，根据这5个byte得到20bit，0001 0100 1011 0110 0010</li><li>然后分成高位的10bit（0001010010）和低位的10bit（1101100010）</li><li>高位+0xD800得到（1101 1000 0101 0010）</li><li>低位+0xDC00得到（1101 1111 0110 0010）</li><li>转换为16进制就是0xD852和0xDF62，这就是这个字的UTF16表示。</li></ol><h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p>这个就简单了，和Unicode码表基本一一对应，固定四个字节。</p><p>为什么不采用UTF-32呢，因为unicode定义的范围太大了，其实99%的人使用的字符编码不会超过2个字节，所以如同统一用4个字节，简单倒是简单了，但是数据冗余确实太大了，不好，所以16位是最好的。就算遇到超过16位能表示的字符，我们也可以通过上面讲到的代理技术，采用32位标识，这样的方案是最好的。所以现在绝大部分机器实现unicode还是采用的utf-16的方案。当然也有UTF-8的方案。比如windows用的就是UTF16方案，不少linux用的就是utf8方案。</p><h2 id="烫烫烫，屯屯屯，锟斤拷"><a href="#烫烫烫，屯屯屯，锟斤拷" class="headerlink" title="烫烫烫，屯屯屯，锟斤拷"></a>烫烫烫，屯屯屯，锟斤拷</h2><p>相信很多人在windows平台遇到过”烫烫烫”，”屯屯屯”，”锟斤铐”等乱码。</p><p>在Windows下,未初始化的栈会初始化为0xcc, 未初始化的堆内存会初始化为0xcd, 而’烫’的gbk编码为0xCC 0xCC,而’屯’的gbk编码为0xCD 0xCD。</p><p>unicode暂时没用到码点会用占位符FFFD来表示, 如果这个占位符被错误解析, 就会被当作有意义的内容了。</p><p>unicode码0xFFFD的utf8编码为0xEF 0xBF 0xDB，汉字”锟斤拷”的gbk编码分别为0XEF 0xBF, oxDB 0xEF和0xBF 0xDB, 正好是两组unicode码0xFFFD的utf8编码的叠加。 </p><p>因此如果平时遇到多个utf8编码的Unicode占位符且不巧用了gbk的方式解码,那就会看到熟悉的锟斤拷了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序猿都遇到过文本编码问题，看到GB2312,GBK,GB18030,Unicode,UTF-8就觉得头大。希望通过此文，可以对文本编码可以有一个透彻的了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编码" scheme="http://melonqi.github.io/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>struct库的使用</title>
    <link href="http://melonqi.github.io/2019/01/13/struct/"/>
    <id>http://melonqi.github.io/2019/01/13/struct/</id>
    <published>2019-01-13T14:03:14.000Z</published>
    <updated>2019-01-14T02:56:08.058Z</updated>
    
    <content type="html"><![CDATA[<p>在解析自定义的二进制的文件格式，或者已知的一些文件格式的时候，比如png图片，tcp包，就需要struct库；</p><p>解析二进制文件长需要的函数有从buffer中读取char(一个字节)，short(两个字节)，int(4字节)，string(n个char)，这些struct都可以很好的胜任。<a href="https://docs.python.org/2/library/struct.html" target="_blank" rel="noopener">官方说明</a></p><a id="more"></a><p>struct生成或者解析二进制的使用方法，很像格式化输出，即使用特定的字符来输出自己想要的格式；</p><h2 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h2><p><code>except</code>：<code>struct.error</code> </p><p><code>struct.pack(fmt,v1,v2,...)</code>: 返回以<code>fmt</code>格式指定的<code>v1,v2,…</code>组成的string; 要求<code>v1,v2,...</code>能够严格匹配<code>fmt</code></p><p><code>struct.pack_into(fmt,buffer,offset,v1,v2,...)</code>: 从buffer的offset处，组成以<code>fmt</code>格式指定组成的<code>v1,v2,...</code></p><p><code>struct.unpack(fmt,string)</code>: 使用<code>fmt</code>解析string，返回结果为tuple，即使只包含一个值。要求<code>len(string)</code>与<code>calcsize(fmt)</code>相同</p><p><code>struct.unpack_from(fmt,buffer[,offset=0])</code>: 从buffer的offset处开始以<code>fmt</code>指定的格式解析，返回结果为tuple，要求<code>len(buffer[offset:])&gt;=calcsize(fmt)</code></p><p><code>struct.calcsize(fmt)</code>: 计算给定格式的字节大小</p><p>fmt可以指定字节序，字符类型等</p><h2 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h2><p>做过相关网络数据包开发的都接触过本地序和网络序；</p><p>对于网络序，使用的大端序(big endian)。</p><p>本地序跟CPU相关</p><ol><li><p>对于Intel X86和AMD64(X86-64)都是小端序(little-endian)</p></li><li><p>Motorola 68000 和 PowerPC G5是大端序</p></li><li><p>对于ARM和Intel Itanium 是双端序</p></li></ol><p>可以使用<code>sys.byteorder</code>来获取当前系统的类型。</p><p>那么什么是大端序，小端序？</p><p>大端序：数据的高位字节存放在地址的低端，低位字节存放在地址的高端</p><p>小端序：数据的高位自己存放在地址的高端，低位字节存放在地址的低端</p><p>数据的高位和低位：举例，<code>int a = 0x12345678</code>, 坐标<code>12</code>是高位字节，右边<code>78</code>是低位字节，从左到右，从高到低；</p><p>地址的高端和低端(假设是64位机器，一个地址是64位)：</p><p><code>0x00000001</code></p><p><code>0x00000002</code></p><p><code>0x00000003</code></p><p><code>0x00000004</code></p><p>从上到下，由低到高，地址值小的为低端，地址值大的为高端。</p><p>假设从地址<code>0x00000001</code>开始存储数<code>0x12345678</code>，则</p><p>大端序存放方式(按原来顺序存放):</p><p><code>0x00000001</code>    –<code>12</code></p><p><code>0x00000002</code>    –<code>34</code></p><p><code>0x00000003</code>    –<code>56</code></p><p><code>0x00000004</code>    –<code>78</code></p><p>小端序存放方式(按颠倒顺序存放)：</p><p><code>0x00000001</code>    –<code>78</code></p><p><code>0x00000002</code>    –<code>56</code></p><p><code>0x00000003</code>    –<code>34</code></p><p><code>0x00000004</code>    –<code>12</code></p><p>struct可以指定使用大端序还是小端序来解析或者生成数据。</p><table><thead><tr><th>Character</th><th>Byte order</th><th>Size</th><th>Alignment</th></tr></thead><tbody><tr><td>@</td><td>native</td><td>native</td><td>native</td></tr><tr><td>=</td><td>native</td><td>standard</td><td>none</td></tr><tr><td>&lt;</td><td>little-endian</td><td>standard</td><td>none</td></tr><tr><td>&gt;</td><td>big-endian</td><td>standard</td><td>none</td></tr><tr><td>!</td><td>network(=big-endian)</td><td>standard</td><td>none</td></tr></tbody></table><p>如果不指定，<code>@</code>是默认值。</p><p>Native size和alignment由C语言的<code>sizeof</code>表达式决定,  即结构体的字节对齐规则。<a href="https://www.cnblogs.com/clover-toeic/p/3853132.html" target="_blank" rel="noopener">C语言的字节对齐问题</a></p><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><table><thead><tr><th>Format</th><th>C Type</th><th>Python type</th><th>Standard size</th><th>Notes</th></tr></thead><tbody><tr><td>x</td><td>pad byte</td><td>no value</td><td></td><td></td></tr><tr><td>c</td><td>char</td><td>string of length 1</td><td>1</td><td></td></tr><tr><td>b</td><td>signed char</td><td>integer</td><td>1</td><td>(3)</td></tr><tr><td>B</td><td>unsigned char</td><td>integer</td><td>1</td><td>(3)</td></tr><tr><td>?</td><td>_Bool</td><td>bool</td><td>1</td><td>(1)</td></tr><tr><td>h</td><td>short</td><td>integer</td><td>2</td><td>(3)</td></tr><tr><td>H</td><td>unsigned short</td><td>integer</td><td>2</td><td>(3)</td></tr><tr><td>i</td><td>int</td><td>integer</td><td>4</td><td>(3)</td></tr><tr><td>I</td><td>unsigned int</td><td>integer</td><td>4</td><td>(3)</td></tr><tr><td>l</td><td>long</td><td>integer</td><td>4</td><td>(3)</td></tr><tr><td>L</td><td>unsigned long</td><td>integer</td><td>4</td><td>(3)</td></tr><tr><td>q</td><td>long long</td><td>integer</td><td>8</td><td>(2),(3)</td></tr><tr><td>Q</td><td>unsigned long long</td><td>integer</td><td>8</td><td>(2),(3)</td></tr><tr><td>f</td><td>float</td><td>float</td><td>4</td><td>(4)</td></tr><tr><td>d</td><td>double</td><td>float</td><td>8</td><td>(4)</td></tr><tr><td>s</td><td>char[]</td><td>string</td><td></td><td></td></tr><tr><td>p</td><td>char[]</td><td>string</td><td></td><td></td></tr><tr><td>P</td><td>void *</td><td>integer</td><td></td><td>(5),(3)</td></tr></tbody></table><p>Notes:</p><ol><li><p><code>?</code> 是C99中的<code>_Bool</code>, 如果不可用， 则生成<code>char</code>, 一个字节；</p></li><li><p><code>q</code>和<code>Q</code>只用当C编译器支持<code>long long</code>;</p></li><li><p>当pack一个非integer类型的时候，如果此非integer有<code>__index__()</code>函数，则pack<code>__init__()</code>的返回值；若没有<code>__index__()</code>或者调用<code>__index__()</code>报异常，则尝试<code>__int__()</code>函数，若没有<code>__int__()</code>则报<code>DeprecationWarning</code>;</p></li><li><p>对于浮点类型，<code>f</code>使用IEEE 754 binary32，<code>d</code>使用binary64标准</p></li><li><p><code>P</code>只在native byte ordering使用</p></li><li><p><code>4h</code>等价于<code>hhhh</code></p></li><li><p><code>&#39;10s&#39;</code>代表  10-byte string, <code>&#39;10c&#39;</code> 代表 10 characters</p></li><li><p><code>p</code> 即<code>Pascal string</code>, 第一个字节代表长度，随后是字符串</p></li></ol><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>示例在big-endian机器，以native byte order,size, alignment </p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; <span class="keyword">from</span> struct <span class="keyword">import</span> *</span><br><span class="line">&gt; &gt;&gt;&gt; pack(<span class="string">'hhl'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&gt; <span class="string">'\x00\x01\x00\x02\x00\x00\x00\x03'</span></span><br><span class="line">&gt; &gt;&gt;&gt; unpack(<span class="string">'hhl'</span>, <span class="string">'\x00\x01\x00\x02\x00\x00\x00\x03'</span>)</span><br><span class="line">&gt; (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&gt; &gt;&gt;&gt; calcsize(<span class="string">'hhl'</span>)</span><br><span class="line">&gt; <span class="number">8</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BytesUtil</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bytes_to_int</span><span class="params">(byte_s)</span>:</span></span><br><span class="line">        <span class="comment"># little_endian</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> reversed(byte_s):</span><br><span class="line">            result = result * <span class="number">256</span> + int(b)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_byte</span><span class="params">(buffer, offset)</span>:</span></span><br><span class="line">        value = struct.unpack_from(<span class="string">"B"</span>, buffer, offset)[<span class="number">0</span>]</span><br><span class="line">        offset += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> value, offset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_short</span><span class="params">(buffer, offset)</span>:</span></span><br><span class="line">        value = struct.unpack_from(<span class="string">"H"</span>, buffer, offset)[<span class="number">0</span>]</span><br><span class="line">        offset += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> value, offset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_int</span><span class="params">(buffer, offset)</span>:</span></span><br><span class="line">        value = struct.unpack_from(<span class="string">"I"</span>, buffer, offset)[<span class="number">0</span>]</span><br><span class="line">        offset += <span class="number">4</span></span><br><span class="line">        <span class="keyword">return</span> value, offset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_int24</span><span class="params">(buffer, offset)</span>:</span></span><br><span class="line">        value, offset = BytesUtil.get_byte_n(<span class="number">3</span>, buffer, offset)</span><br><span class="line">        <span class="keyword">return</span> BytesUtil.bytes_to_int(value), offset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_byte_n</span><span class="params">(n, buffer, offset)</span>:</span></span><br><span class="line">        value = struct.unpack_from(<span class="string">"%dB"</span> % (n), buffer, offset)</span><br><span class="line">        offset += n</span><br><span class="line">        <span class="keyword">return</span> value, offset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_short_n</span><span class="params">(n, buffer, offset)</span>:</span></span><br><span class="line">        value = struct.unpack_from(<span class="string">"%dH"</span> % (n), buffer, offset)</span><br><span class="line">        offset += <span class="number">2</span>*n</span><br><span class="line">        <span class="keyword">return</span> value, offset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_int_n</span><span class="params">(n, buffer, offset)</span>:</span></span><br><span class="line">        value = struct.unpack_from(<span class="string">"%dI"</span> % (n), buffer, offset)</span><br><span class="line">        offset += <span class="number">4</span>*n</span><br><span class="line">        <span class="keyword">return</span> value, offset</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在解析自定义的二进制的文件格式，或者已知的一些文件格式的时候，比如png图片，tcp包，就需要struct库；&lt;/p&gt;
&lt;p&gt;解析二进制文件长需要的函数有从buffer中读取char(一个字节)，short(两个字节)，int(4字节)，string(n个char)，这些struct都可以很好的胜任。&lt;a href=&quot;https://docs.python.org/2/library/struct.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方说明&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://melonqi.github.io/tags/python/"/>
    
  </entry>
  
</feed>
